#!/usr/bin/env node
const { existsSync } = require('node:fs')
const FS = require('node:fs/promises')
const Path = require('node:path/posix')

const { red, green } = require('colorette')

const main = async () => {
  const fix = process.argv.slice(2).includes('--fix')

  const versions = JSON.parse(
    await FS.readFile(Path.join(__dirname, './versions.json'))
  )

  const rules = (await FS.readdir(Path.join(__dirname, 'rules')))
    .filter((filename) => !filename.includes('scripts-are-configured'))
    .map((filename) => filename.replace(/\.js$/, ''))
    .map((name) => ({ name, check: require(`./rules/${name}`) }))

  const packages = await FS.readdir(Path.join(__dirname, '../packages'))
  let failed = 0

  const padWidth = Math.max(...packages.map((_) => _.length)) + 1

  for (const package of packages) {
    const path = Path.resolve(__dirname, '../packages', package)
    const packagePath = Path.join(path, 'package.json')
    if (!existsSync(packagePath)) {
      process.stderr.write(
        `${green(`[INFO]`)} ${'no package.json file '.padEnd(
          padWidth + 1,
          '-'
        )} ${package}\n`
      )
      continue
    }

    try {
      const packageJson = await FS.readFile(packagePath, 'utf-8')
      const packageObj = JSON.parse(packageJson)
      for (const rule of rules) {
        try {
          const output = await rule.check({
            package: packageObj,
            path,
            versions,
            fix,
          })

          if (!output) {
            continue
          }

          const { result, errors } = output

          if (fix && result && typeof result === 'object') {
            console.log(`writing ${path}${errors ? `\n${errors}` : null}`)
            const json = JSON.stringify(result, null, 2)
            await FS.writeFile(packagePath, json, 'utf-8')
          }
        } catch (e) {
          failed++
          process.stderr.write(
            `${red('[FAIL]')} ${(package + ' ').padEnd(padWidth, '-')}- ${
              rule.name
            }: ${e}\n`
          )
        }
      }
    } catch (e) {
      process.stderr.write(`failed to read/parse file: ${path} ${e}\n`)
    }
  }

  if (failed) {
    process.stderr.write(
      `______________________________________________________________\n\n`
    )
    process.stderr.write(`Lint failed: ${failed} rules broken\n`)
    process.exitCode = 1
  }
}

main().catch((e) => {
  process.stderr.write(`lint failed: ${e}\n`)
  process.exitCode = 1
})
